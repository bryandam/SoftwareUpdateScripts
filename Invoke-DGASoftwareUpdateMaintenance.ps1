<#
.SYNOPSIS
Maintain Software Updates in System Center Configuration Manager.
.DESCRIPTION
This script can be used to perform numerous software update maintenance tasks.  It can be used to decline updates based on supersedence, title, or external plugins.  By declining updates you remove them from the catalog that clients scan against.  This reduces the amount of resources required by the server to generate the catalog and for the client to perform the scan.  In extreme cases this can be the difference between failure and success.  The script can also remove the declined updates and any expired updates from all Software Update Groups.  Lastly, the script can also remove any unneeded updates from the deployment package source folders.  It's recommended to first run the script with the -WhatIf switch to determine the impact of running the script.
.EXAMPLE
Powershell -File .\Invoke-DGASoftwareUpdateMaintenance.ps1 -FirstRun -Force
Call the WSUS database's internal stored procedures to delete obsolete updates.  Use this to do the initial cleanup in environments that have never been maintained.
.EXAMPLE
Powershell -File .\Invoke-DGASoftwareUpdateMaintenance.ps1 -RunCleanUpWizard -Force
Run WSUS cleanup wizard.  If the script has been ran in the last 24 hours force it to run anyways.
.EXAMPLE
Powershell -File .\Invoke-DGASoftwareUpdateMaintenance.ps1 -DeclineSuperseded -UpdateListOutputFile OutFile.csv
Decline all superseded updates older than the period defined in the site's software update component.  Output a list of declined updates to OutFile.csv.
.EXAMPLE
Powershell -File .\Invoke-DGASoftwareUpdateMaintenance.ps1 -DeclineSuperseded -DeclineLastLevelOnly
Decline all superseded updates older than the period defined in the site's software update component and do not supersede other updates.
.EXAMPLE
Powershell -File .\Invoke-DGASoftwareUpdateMaintenance.ps1 -DeclineSuperseded -ExclusionPeriod 6
Decline all superseded updates older than 6 months.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -DeclineByTitle @('*Itanium*','*ia64*','*Beta*')"
Decline all updates whose titles include the words 'Itanium', 'ia64', or 'Beta'.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -CleanSUGs -RemoveEmptySUGs"
Remove declined and expired updates from all software update groups and delete remove any empty software update groups.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -CombineSUGs 3 -CleanSources"
Combine and remove ADR generated software updates groups where more than three exist and remove unnecessary updates from the deployment package source files.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -UpdateADRDeploymentPackages Monthly"
Verify that each automatic deployment is using a deployment package for the current month.  If the package does not exist then create it.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -MaxUpdateRuntime @{'*Security Monthly Quality Rollup For Windows*'=60;'*Security and Quality Rollup for .NET*'=120}"
Set the maximum runtime to 60 minutes for Windows cumulative rollups and 120 minutes for the .NET cumulative rollups.
.EXAMPLE
Powershell -Command "& '.\Invoke-DGASoftwareUpdateMaintenance.ps1' -DeclineSuperseded -DeclineByTitle @('*Itanium*','*ia64*','*Beta*') -DeclineByPlugins -ReSyncUpdates -CleanSUGs -RemoveEmptySUGs -CombineSUGs 3 -UpdateADRDeploymentPackages Yearly -MaxUpdateRuntime @{'*Security Monthly Quality Rollup For Windows*'=60;'*Security and Quality Rollup for .NET*'=30}" -CleanSources"
Run WSUS cleanup wizard and decline all superseded updates older than the period defined in the site's software update component, all updates whose titles include the words 'Itanium', 'ia64', or 'Beta', and updates based on external plugin files.  Then initiate an update synchronization, remove declined and expired updates from all software update groups, remove any empty software update groups, combine and remove software updates groups generated by automatic deployment rules where more than three exist, verify that the automatic deployment rules are using the correct yearly deployment package, set the maximum runtime to 60 minutes for Windows cumulative rollups and 30 minutes for the .NET cumulative rollups, and remove unnecessary updates from the deployment package source files.
.NOTES
The script will create an empty text file in the root of its folder to track the last time it was ran and will not run if this file is newer than 24 hours old.  Use the -Force parameter to override.

The DeclineByTitle parameter takes an array of strings and the MaximumUpdateRuntime takes a hashtable.  While the script has logic to try and interpret normal strings as both types it is recommended that you call the program using the -Command option when using these parameters so that you can pass the proper object type.

When using the MaximumUpdateRuntime parameter note that when Configuration Manager syncs updates that it will revert to the default value if it is higher than your custom setting.


Written By: Bryan Dam
Version 1.1: 10/15/17
Version 1.2: 10/17/17
Version 1.3: 10/20/17
Version 1.4: 10/23/17
Version 1.5: 10/28/17
Version 1.6: 11/05/17
Version 1.7: 03/02/18
Version 1.8: 04/09/18 Renamed the MaxiumumUpateRuntime  to MaxUdateRuntime b/c I'm a dumbass that can't spell
Version 1.9: 04/09/18 Renamed MaxUdateRuntime to MaxUpdateRuntime, removed .Where calls for PoSH 3 compatibility, added SiteCode parameter to cmdlets that support it for multi-site environments
Version 2.0: 04/09/18 
    Added FirstRun parameter used to try and get past timeouts in environments that have not been maintained.  
    Fixed issues with CleanSources routine.
    Added/fixed pretty progress bars when running interactively.
    Make ExclusionPeriod nullable so that null can be detected and zero can be passed properly.
Version 2.1 ##/##/##
    Fixed issue formatting the percent figure for progress bars.
Version 2.2: 05/23/18 Added exclusion of Windows 10 Feature Updates from superseded list.  Added support for PowerShell ISE

.LINK
http://www.damgoodadmin.com
#>


[CmdletBinding(SupportsShouldProcess=$True)]
Param(
	
    #Connect to the WSUS database directly and use the built in stored procedures to delete obsolete updates.
    [switch] $FirstRun,

    #Decline superseded updates.
    [switch] $DeclineSuperseded,

    #Only decline the last level of superseded updates which do not supersede any other updates.
    [switch] $DeclineLastLevelOnly,
	
    #Only decline superseded updates that haven't been modified for the given number of months.
    [System.Nullable[int]] $ExclusionPeriod,

    #Array of strings to search for and decline updates that match.  Use wildcard operator (*) to match more than one update.
    [string[]] $DeclineByTitle,

    #Run powershell scripts in the plugin folder to select updates to decline.
    [switch] $DeclineByPlugins,

    #Output the list of updates to this file.
    [string] $UpdateListOutputFile,
    
    #Run the WSUS cleanup wizard.  This occurs after declining updates.
    [switch] $RunCleanUpWizard,

    #Set the log file.
    [string] $LogFile,

    #The maximum size of the log in bytes.
    [int]$MaxLogSize = 2621440,

    #The number of minutes to wait after the last sync to run the wizard.
    [int]$SyncLeadTime = 5,

    #Force the script to run even if it was run recently.
    [switch]$Force,

    #After declining updates resync the update catalog to bring the changes into Configuration Manager.
    [switch]$ReSyncUpdates,

    #When declining an update also remove it from all software update groups.
    [switch]$CleanSUGs,

    #If a software update group is left empty, remove it.
    [switch]$RemoveEmptySUGs,

    #Combine software updates groups into yearly groups leaving only the provided number of groups.
    [Parameter( HelpMessage="A number greater than zero.")]
    [ValidateRange(1,[int]::MaxValue)]
    [int]$CombineSUGs,

    #A list of update title searches and the maximum runtime to set those updates to.
    [Alias("MaxiumumUpateRuntime ")]
    $MaxUpdateRuntime,

    #Clean up any source files that are no longer associated to an active deployment.
    [switch]$CleanSources,

    #Updates the distribution packages used by ADRs.
    [Parameter( HelpMessage="You must select either Yearly or Monthly distribution packages for the automatic deployment rules.")]
    [ValidateSet("Yearly","Monthly")]
    [string]$UpdateADRDeploymentPackages,

    #Define the sitecode.
    [string] $SiteCode
)


Function Add-TextToCMLog {
##########################################################################################################
<#
.SYNOPSIS
   Log to a file in a format that can be read by Trace32.exe / CMTrace.exe 

.DESCRIPTION
   Write a line of data to a script log file in a format that can be parsed by Trace32.exe / CMTrace.exe

   The severity of the logged line can be set as:

        1 - Information
        2 - Warning
        3 - Error

   Warnings will be highlighted in yellow. Errors are highlighted in red.

   The tools to view the log:

   SMS Trace - http://www.microsoft.com/en-us/download/details.aspx?id=18153
   CM Trace - Installation directory on Configuration Manager 2012 Site Server - <Install Directory>\tools\

.EXAMPLE
   Add-TextToCMLog c:\output\update.log "Application of MS15-031 failed" Apply_Patch 3

   This will write a line to the update.log file in c:\output stating that "Application of MS15-031 failed".
   The source component will be Apply_Patch and the line will be highlighted in red as it is an error 
   (severity - 3).

#>
##########################################################################################################

#Define and validate parameters
[CmdletBinding()]
Param(
      #Path to the log file
      [parameter(Mandatory=$True)]
      [String]$LogFile,

      #The information to log
      [parameter(Mandatory=$True)]
      [String]$Value,

      #The source of the error
      [parameter(Mandatory=$True)]
      [String]$Component,

      #The severity (1 - Information, 2- Warning, 3 - Error)
      [parameter(Mandatory=$True)]
      [ValidateRange(1,3)]
      [Single]$Severity
      )


#Obtain UTC offset
$DateTime = New-Object -ComObject WbemScripting.SWbemDateTime 
$DateTime.SetVarDate($(Get-Date))
$UtcValue = $DateTime.Value
$UtcOffset = $UtcValue.Substring(21, $UtcValue.Length - 21)


#Create the line to be logged
$LogLine =  "<![LOG[$Value]LOG]!>" +`
            "<time=`"$(Get-Date -Format HH:mm:ss.fff)$($UtcOffset)`" " +`
            "date=`"$(Get-Date -Format M-d-yyyy)`" " +`
            "component=`"$Component`" " +`
            "context=`"$([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)`" " +`
            "type=`"$Severity`" " +`
            "thread=`"$($pid)`" " +`
            "file=`"`">"

#Write the line to the passed log file
Out-File -InputObject $LogLine -Append -NoClobber -Encoding Default -FilePath $LogFile -WhatIf:$False

}
##########################################################################################################

Function Get-CMSoftwareUpdateSyncStatus {
##########################################################################################################
<#
.SYNOPSIS
   Returns the sync status for each software update point in the site.
.NOTES
   This function is provided in 1706 so this is just a stop-gap until that version has reached critical mass.
#>
##########################################################################################################

$SyncStatus = Get-WmiObject -Namespace "ROOT\SMS\site_$($SiteCode)" -Query "Select * from SMS_SUPSyncStatus"
$Results = @()

#Create a new object to convert WMI's CIM_DATETIME to PowerShell DateTime
ForEach ($status in $SyncStatus){
    If ($status.LastReplicationLinkCheckTime){ $LastReplicationLinkCheckTime = [Management.ManagementDateTimeConverter]::ToDateTime($status.LastReplicationLinkCheckTime)}
    If ($status.LastSuccessfulSyncTime){ $LastSuccessfulSyncTime = [Management.ManagementDateTimeConverter]::ToDateTime($status.LastSuccessfulSyncTime)}
    If ($status.LastSyncStateTime){ $LastSyncStateTime = [Management.ManagementDateTimeConverter]::ToDateTime($status.LastSyncStateTime)}


    $properties = @{'LastReplicationLinkCheckTime'=$LastReplicationLinkCheckTime;
                'LastSuccessfulSyncTime'=$LastSuccessfulSyncTime;
                'LastSyncErrorCode'=$status.LastSyncErrorCode;
                'LastSyncState'=$status.LastSyncState;
                'LastSyncStateTime'=$LastSyncStateTime;
                'ReplicationLinkStatus'=$status.ReplicationLinkStatus;
                'SiteCode'=$status.SiteCode;
                'SyncCatalogVersion'=$status.SyncCatalogVersion;
                'WSUSServerName'=$status.WSUSServerName;
                'WSUSSourceServer'=$status.WSUSSourceServer}

    $Results+= New-Object –TypeName PSObject –Prop $properties
}


Return $Results

}
##########################################################################################################

Function Invoke-SyncCheck {
##########################################################################################################
<#
.SYNOPSIS
   Invoke a synchronization check on all software update points.

.DESCRIPTION
   When ran this function will wait for the software update point synchronization process to complete
   successfully before continuing.

.EXAMPLE
   Invoke-SyncCheck

#>
##########################################################################################################
    [CmdletBinding()]
    Param(
        #The number of minutes to wait after the last sync to run the wizard.
        [int]$SyncLeadTime = 5
    )

    $WaitInterval = 0 #Used to skip the initial wait cycle if it isn't necessary.
    Do{
    
        #Wait until the loop has iterated once.
        If ($WaitInterval -gt 0){
            Add-TextToCMLog $LogFile "Waiting $TimeToWait minutes for lead time to pass before executing." $component 1
            Start-Sleep -Seconds ($WaitInterval)  
        }    

        #Loop through each SUP and wait until they are all done syncing.
        Do {
            #If syncronizing then wait.
            If($Syncronizing){
                Add-TextToCMLog $LogFile "Waiting for software update points to stop syncing." $component 1  
                Start-Sleep -Seconds (300)  
            }

            $Syncronizing = $False
            ForEach ($softwareUpdatePointSyncStatus in Get-CMSoftwareUpdateSyncStatus){
                If($softwareUpdatePointSyncStatus.LastSyncState -eq 6704){$Syncronizing = $True}
            }
        } Until(!$Syncronizing)


        #Loop through each SUP, calculate the last sync time, and make sure that they all synced successfully.
        $syncTimeStamp = Get-Date "1/1/2001 12:00 AM"
        ForEach ($softwareUpdatePointSyncStatus in Get-CMSoftwareUpdateSyncStatus){
            If ($softwareUpdatePointSyncStatus.LastSyncErrorCode -ne 0){
                Add-TextToCMLog $LogFile "The software update point $($softwareUpdatePointSyncStatus.WSUSServerName) failed its last synchronization with error code $($softwareUpdatePointSyncStatus.LastSyncErrorCode).  Synchronize successfully before running $component." $component 2
                Return
            }

            If ($syncTimeStamp -lt $softwareUpdatePointSyncStatus.LastSyncStateTime) {
                $syncTimeStamp = $softwareUpdatePointSyncStatus.LastSyncStateTime
            }
        }

 
        #Calculate the remaining time to wait for the lead time to expire.
        $TimeToWait = ($syncTimeStamp.AddMinutes($SyncLeadTime) - (Get-Date)).Minutes

        #Set the wait interval in seconds for subsequent loops.
        $WaitInterval = 300
    } Until ($TimeToWait -le 0)

    Add-TextToCMLog $LogFile "Software update point synchronization states confirmed." $component 1
}
##########################################################################################################


Function Test-RegistryValue {
##########################################################################################################
#.NOTES
#    Taken from https://stackoverflow.com/questions/5648931/test-if-registry-value-exists
    Param(
        [Alias("PSPath")]
        [Parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [String]$Path,
        [Parameter(Position = 1, Mandatory = $true)]
        [String]$Value,
        [Switch]$PassThru
    ) 

    Process {
        If (Test-Path $Path) {
            $Key = Get-Item -LiteralPath $Path
            If ($Key.GetValue($Value, $null) -ne $null) {
                If ($PassThru) {
                    Get-ItemProperty $Path $Value
                } Else {
                    $True
                }
            } Else {
                $False
            }
        } Else {
            $False
        }
    }
}
##########################################################################################################


Function Get-SiteCode {
##########################################################################################################
<#
.SYNOPSIS
   Attempt to determine the current device's site code from the registry or PS drive.

.DESCRIPTION
   When ran this function will look for the client's site.  If not found it will look for a single PS drive.

.EXAMPLE
   Get-SiteCode

#>
##########################################################################################################
    
    #Try getting the site code from the client installed on this system.
    If (Test-RegistryValue -Path "HKLM:\SOFTWARE\Microsoft\SMS\Identification" -Value "Site Code"){
        $SiteCode =  Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Identification" | Select-Object -ExpandProperty "Site Code"
    } ElseIf (Test-RegistryValue -Path "HKLM:\SOFTWARE\Microsoft\SMS\Mobile Client" -Value "AssignedSiteCode") {            
        $SiteCode =  Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\SMS\Mobile Client" | Select-Object -ExpandProperty "AssignedSiteCode"
    }

    #If the client isn't installed try looking for the site code based on the PS drives.
    If (-Not ($SiteCode) ) {
        #See if a PSDrive exists with the CMSite provider        
        $PSDrive = Get-PSDrive -PSProvider CMSite -ErrorAction SilentlyContinue     

        #If PSDrive exists then get the site code from it.
        If ($PSDrive.Count -eq 1) {        
            $SiteCode = $PSDrive.Name
        }
    }
    
    Return $SiteCode
}
##########################################################################################################

$cmSiteVersion = [version]"5.00.8540.1000"
$scriptVersion = "2.2"


#If log file is null then set it to the default and then make the provider type explicit.
If (!$LogFile) {
	try {
		$LogFile = Join-Path $PSScriptRoot "updatemaint.log"
	} catch {
		$LogFile = Join-Path $psISE.CurrentFile.FullPath "updatemaint.log"
	}
}
$LogFile = "filesystem::$($LogFile)"

#If out file was given then make the provider type explicit.
If ($UpdateListOutputFile){$UpdateListOutputFile = "filesystem::$($UpdateListOutputFile)"}

#Generate the compnent used for loggins based on the script name.
try {
	$component = (Split-Path $PSCommandPath -Leaf).Replace(".ps1", "")
} catch {
	$component = 'Invoke-DGASoftwareUpdateMaintenance'
}

#If the log file exists and is larger then the maximum then roll it over.
If (Test-path  $LogFile -PathType Leaf) {    
    If ((Get-Item $LogFile).length -gt $MaxLogSize){
        Move-Item -Force $LogFile ($LogFile -replace ".$","_") -WhatIf:$False
    }
}

Add-TextToCMLog $LogFile "$component started (Version $($scriptVersion))." $component 1

#Check to see if this script has ran recently.
try {
	$lastRanPath = "filesystem::$(Join-Path $PSScriptRoot "lastran_$($component)")"
} catch {
	$lastRanPath = "filesystem::$(Join-Path -Path $(Split-Path -Path $LogFile -Parent) -ChildPath "lastran_$(Split-Path -Path $LogFile -Leaf)")"
}

If (Test-Path -Path $lastRanPath -NewerThan ((get-date).AddHours(-24).ToString())){
    If ($Force){
        Add-TextToCMLog $LogFile "The script was run in the last 24 hours but is being forced to run." $component 1
    } Else {
        Add-TextToCMLog $LogFile "The script was run in the last 24 hours.  Use the Force parameter to run the script anyways." $component 2
        Return
    }
}

#Mark the last time the script ran.  We do this now and at the end to avoid running multiple instances of the script at the same time.
Get-Date | Out-File $lastRanPath -Force -WhatIf:$False

#Check to make sure we're running this on a primary site server that has the SMS namespace.
If (! (Get-Wmiobject -namespace "Root" -class "__Namespace" -Filter "Name = 'SMS'")){
    Add-TextToCMLog $LogFile "Currently, this script must be ran on a primary site server. When the CM 1706 reaches critical mass this requirement might be removed." $component 3
    Return
}

#Make sure at least one action parameter was given.
If (!$FirstRun -and !$DeclineSuperseded -and !$DeclineByTitle -and !$DeclineByPlugins -and !$RunCleanUpWizard -and !$CleanSUGs -and !$CombineSUGs -and !$UpdateADRDeploymentPackages -and !$CleanSources -and !$MaxUpdateRuntime) {
    Add-TextToCMLog $LogFile "You must choose one of the action parameters: FirstRun, DeclineSuperseded, DeclineByTitle, DeclineByPlugins, RunCleanupWizard, CleanSUGs, CombineSUGs, UpdateADRDeploymentPackages, CleanSources, or MaximumUpdateRuntime." $component 2
    Return
}

#Make sure the superseded updates parameters make sense.
If (($ExclusionPeriod -or $DeclineLastLevelOnly) -and !$DeclineSuperseded){
    Add-TextToCMLog $LogFile "You must use the DeclineSuperseded parameter when using the ExclusionPeriod or DeclineLastLevelOnly parameters." $component 3
    Return
}

#Make sure the remove empty SUG parameter is only sent when cleaning up the SUGs.
If ($RemoveEmptySUGs -and !$CleanSUGs){
    Add-TextToCMLog $LogFile "You must use the RemoveEmptySUGs parameter with the CleanSUGs parameter." $component 3
    Return
}


#If the DeclineByTitle parameter doesn't look right (only one element with commas in it) then try to split it.
If ($DeclineByTitle){
    If ($DeclineByTitle.Count -eq 1){
        If ($DeclineBytitle[0] -like '*,*'){            
            $DeclineBytitle = $DeclineBytitle[0].Split(",")
            Add-TextToCMLog $LogFile "The DeclineByTitle array parameter only had one element that contained commas.  It has been split into $($DeclineBytitle.Count) separate elements." $component 2
        }
    }
}

#If the MaximumUpdateRuntime isn't a hashtable then see if it can be interpreted as such.
If ($MaxUpdateRuntime){
    If ($MaxUpdateRuntime.GetType() -eq [System.Collections.Hashtable]){
        #Do nothing, the user successfully passed a hashtable.  Good job user ... good job.
    } ElseIf ($MaxUpdateRuntime.GetType() -eq [System.String]){        

        #If the string doesn't contain valid newline characters but does contain semi-colons then swap them.
        If(($MaxUpdateRuntime -notmatch '`n') -and ($MaxUpdateRuntime -match ';')){            
            $MaxUpdateRuntime = $MaxUpdateRuntime.Replace(";","`n")
        }
        Try{            
            $MaxUpdateRuntime = ConvertFrom-StringData $MaxUpdateRuntime
        } Catch {
            Add-TextToCMLog $LogFile "Failed to convert the MaximumUpdateRuntime value from a string to a hashtable.  This parameter will be ignored." $component 2            
            Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 2
            Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 2
            $MaxUpdateRuntime = $null
        }
        
        #If it's a hashtable now, dance with rejoice and let the user know.  Otherwise ... sad face.
        If ($MaxUpdateRuntime.GetType() -eq [System.Collections.Hashtable]){
            Add-TextToCMLog $LogFile "The MaximumUpdateRuntime paramter was converted from a string to a hashtable with $($MaxUpdateRuntime.Count) values." $component 2
        } Else {
            $MaxUpdateRuntime = $null
            Add-TextToCMLog $LogFile "Attempted to convert the MaximumUpdateRuntime value into a hashtable but could not.  This parameter will be ignored" $component 2
        }

    } Else {
        Write-Host "You must pass either a string or a hashtable for the -Hash parameter."
    }
}

#If the UpdateServices module doesn't exist then exit.
If (!(Get-Module -ListAvailable -Name 'UpdateServices')) {
    Add-TextToCMLog $LogFile "The Update Services module was not found.  Please make sure that WSUS Admin Console is installed on this machine" $component 3
    Return
}

#Try to load the UpdateServices module.
#NOTE: I initially tried using the WSUS Powershell module but it was exponentially slower than the API calls.  Instead of a seconds it took hours to get the update list.
Try {
    [reflection.assembly]::LoadWithPartialName("Microsoft.UpdateServices.Administration") | out-null
} Catch { 
    Add-TextToCMLog $LogFile "Failed to load the UpdateServices module." $component 3
    Add-TextToCMLog $LogFile "Please make sure that WSUS Admin Console is installed on this machine" $component 3
    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
}

#If the Configuration Manager module exists then load it.
If (! $env:SMS_ADMIN_UI_PATH)
{
    Add-TextToCMLog $LogFile "The SMS_ADMIN_UI_PATH environment variable is not set.  Make sure the Configuration Manager console it installed." $component 3
    Return
}
$configManagerCmdLetpath = Join-Path $(Split-Path $env:SMS_ADMIN_UI_PATH) "ConfigurationManager.psd1"
If (! (Test-Path $configManagerCmdLetpath -PathType Leaf) )
{
    Add-TextToCMLog $LogFile "The ConfigurationManager Module file could not be found.  Make sure the Configuration Manager console it installed." $component 3
    Return
}

#You can't pass WhatIf to the Import-Module function and it spits out a lot of text, so work around it.
$WhatIf = $WhatIfPreference
$WhatIfPreference = $False
Import-Module $configManagerCmdLetpath -Force
$WhatIfPreference = $WhatIf

#Get the site code
If (!$SiteCode){$SiteCode = Get-SiteCode}

#Verify that the site code was determined
If (!$SiteCode){
    Add-TextToCMLog $LogFile "Could not determine the site code. If you are running CAS you must specify the site code. Exiting." $component 3
    Return
}

#If the PS drive doesn't exist then try to create it.
If (! (Test-Path "$($SiteCode):")) {
    Try{
        Add-TextToCMLog $LogFile "Trying to create the PS Drive for site '$($SiteCode)'" $component 1
        New-PSDrive -Name $SiteCode -PSProvider CMSite -Root "." -WhatIf:$False | Out-Null   
    } Catch {
        Add-TextToCMLog $LogFile "The site's PS drive doesn't exist nor could it be created." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3    
        Return
    }
}

#Change the directory to the site location.
$OriginalLocation = Get-Location

#Set and verify the location.
Try{
    Add-TextToCMLog $LogFile "Connecting to site: $($SiteCode)" $component 1        
    Set-Location "$($SiteCode):"  | Out-Null
} Catch {
    Add-TextToCMLog $LogFile "Could not set location to site: $($SiteCode)." $component 3
    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    Return
}

#Make sure the site code exists on this server.
$CMSite = Get-CMSite -SiteCode $SiteCode
If (!$CMSite) {
    Add-TextToCMLog $LogFile "The site code $($SiteCode) could not be found." $component 3
    Return
}

#Verify the site version meets the requirement.
If ($CMSite.Version -lt $cmSiteVersion){
    Write-Warning "$($ModuleName) requires Configuration Manager $($cmSiteVersion.ToString()) or greater."
}

Try {   

    #Determine the active SUP.
    $ActiveSoftwareUpdatePointName = (((Get-CMSoftwareUpdatePointComponent -SiteCode $SiteCode).Props) | Where-Object {$_.PropertyName -eq 'DefaultWSUS'}).Value2
    $ActiveSoftwareUpdatePoint = Get-CMSoftwareUpdatePoint -SiteCode $SiteCode -SiteSystemServerName $ActiveSoftwareUpdatePointName

    #Verify that an active SUP was found.
    If (!$ActiveSoftwareUpdatePoint){
        Add-TextToCMLog $LogFile "The active software update point ($ActiveSoftwareUpdatePointName) could not be found." $component 3
        Set-Location $OriginalLocation
        Return
    }
    Add-TextToCMLog $LogFile "The active software update point is $ActiveSoftwareUpdatePointName." $component 1

    #Determine if the active SUP is using SSL and what port.
    $ActiveSoftwareUpdatePointSSL = (($ActiveSoftwareUpdatePoint.Props) | Where-Object {$_.PropertyName -eq 'SSLWSUS'}).Value
    $ActiveSoftwareUpdatePointPort = 8530
    If ($ActiveSoftwareUpdatePointSSL){
        $ActiveSoftwareUpdatePointPort = (($ActiveSoftwareUpdatePoint.Props) | Where-Object {$_.PropertyName -eq 'WSUSIISSSLPort'}).Value
        Add-TextToCMLog $LogFile "Trying to connect to $ActiveSoftwareUpdatePointName on Port $ActiveSoftwareUpdatePointPort using SSL." $component 1
    } Else {
        $ActiveSoftwareUpdatePointPort = (($ActiveSoftwareUpdatePoint.Props) | Where-Object {$_.PropertyName -eq 'WSUSIISPort'}).Value
        Add-TextToCMLog $LogFile "Trying to connect to $ActiveSoftwareUpdatePointName on Port $ActiveSoftwareUpdatePointPort." $component 1
    }
    
    $WSUSServer = [Microsoft.UpdateServices.Administration.AdminProxy]::GetUpdateServer($ActiveSoftwareUpdatePointName, $ActiveSoftwareUpdatePointSSL, $ActiveSoftwareUpdatePointPort)
} Catch {    
    Add-TextToCMLog $LogFile "Failed to connect to the active software update point $ActiveSoftwareUpdatePointName on port $ActiveSoftwareUpdatePointPort" $component 3
    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3            
    $WSUSServer = $null
    Set-Location $OriginalLocation
    Return
}

#If the WSUS object is not instantiated then exit.
If ($WSUSServer -eq $null) {
    Add-TextToCMLog $LogFile "Failed to connect." $component 3
    Add-TextToCMLog $LogFile "Please make sure that WSUS Admin Console is installed on this machine" $component 3
    Set-Location $OriginalLocation
    Return 
 } 

Add-TextToCMLog $LogFile "Connected to active software update point $ActiveSoftwareUpdatePointName." $component 1

#If the user has used the FirstRun parameter.
If($FirstRun){

    Add-TextToCMLog $LogFile "User selected FirstRun. Will try to delete obsolete updates by directly calling the database store procedures." $component 1
    
    Try{
        $WSUSServerDB = $WSUSServer.GetDatabaseConfiguration()
    }
    Catch{
        Add-TextToCMLog $LogFile "Failed to get the WSUS database details from the active SUP." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
        Break
    }

    If (!($WSUSServerDB)){
        Add-TextToCMLog $LogFile "Failed to get the WSUS database details from the active SUP." $component 3
        Break
    }

    #This is a just a test built into the API, it's not actually making the connection we'll use.     
    Try{
        $WSUSServerDB.ConnectToDatabase()
        Add-TextToCMLog $LogFile "Successfully tested the connection to to the ($($WSUSServerDB.DatabaseName)) database on $($WSUSServerDB.ServerName)." $component 1
    }
    Catch{
        Add-TextToCMLog $LogFile "Failed to connect to the ($($WSUSServerDB.DatabaseName)) database on $($WSUSServerDB.ServerName)." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
        Break
    }    

    #Determine the connection string based on the type of DB being used.
    If ($WSUSServerDB.IsUsingWindowsInternalDatabase){
        #Using the Windows Internal Database.  Come one dawg ... just stop this insanity and migrate this to SQL.
        If($WSUSServerDB.ServerName -eq "MICROSOFT##WID"){
            $SqlConnectionString = "Data Source=\\.\pipe\MICROSOFT##WID\tsql\query;Integrated Security=True;Network Library=dbnmpntw"
        }
        Else{
            $SqlConnectionString = "Data Source=\\.\pipe\microsoft##ssee\sql\query;Integrated Security=True;Network Library=dbnmpntw"
        }        
    }
    Else{
        #Connect to a real SQL database.
        $SqlConnectionString = "Server=$($WSUSServerDB.ServerName);Database=$($WSUSServerDB.DatabaseName);Integrated Security=True"
    }
    
    #Try to connect to the database.
    Try{
        $SqlConnection = New-Object System.Data.SqlClient.SqlConnection($SqlConnectionString)
	    $SqlConnection.Open()   
        Add-TextToCMLog $LogFile "Successfully connected to to the database." $component 1
    }
    Catch{
        Add-TextToCMLog $LogFile "Failed to connect to the database using the connection string $($SqlConnectionString)." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
        Break
    }
    
    #Get all the obsolete updates to remove.
    Try{
        $WSUSStoreProcedureName = "spGetObsoleteUpdatesToCleanup"     
	    $SqlCmd = $SqlConnection.CreateCommand()
        $SqlCmd.CommandTimeout = 1800 #30 minutes
	    $SqlCmd.CommandText = "USE $($WSUSServerDB.DatabaseName);exec $($WSUSStoreProcedureName)" 
	    $SqlDataAdapter = New-Object System.Data.SqlClient.SqlDataAdapter($SqlCmd)        
	    $ObsoleteUpdates = New-Object System.Data.DataTable
	    [void]$SqlDataAdapter.Fill($ObsoleteUpdates)
	
        Add-TextToCMLog $LogFile "The WSUS $($WSUSStoreProcedureName) stored procedure returned $($ObsoleteUpdates.Rows.Count) updates." $component 1
    }
    Catch{
        Add-TextToCMLog $LogFile "Failed to call the WSUS $($WSUSStoreProcedureName) stored procedure." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
        Break
    }

    #Loop through each result and delete
    If ($WhatIfPreference) {Add-TextToCMLog $LogFile "The WhatIf parameter was sent.  No obsolete updates will actually be deleted." $component 2}
    For ($i=0; $i -lt $ObsoleteUpdates.Rows.Count; $i++)
    {

        #Track the progress all pretty-like.
        $percentComplete = [math]::Round((($i/$countAllUpdates) * 100))
	    Write-Progress -Activity "Deleting Obsolete Updates" -Status "Deleting update $($ObsoleteUpdates.Rows[$i][0]) ($($i)/$($ObsoleteUpdates.Rows.Count))" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"

        Add-TextToCMLog $LogFile "Attempting to delete update $($ObsoleteUpdates.Rows[$i][0]) ($($i + 1)/$($($ObsoleteUpdates.Rows.Count)))." $component 1
        If (!($WhatIfPreference)){
            Try{
                $WSUSStoreProcedureName = "spDeleteUpdate"
                $SqlCmd.CommandText = "$WSUSStoreProcedureName '$($ObsoleteUpdates.Rows[$i][0])'"
	            $SqlDataAdapter = New-Object System.Data.SqlClient.SqlDataAdapter($SqlCmd)
	            $DeletedUpdate = New-Object System.Data.DataTable
	            [void]$SqlDataAdapter.Fill($DeletedUpdate)
            }
            Catch{
                Add-TextToCMLog $LogFile "Failed to delete update $($ObsoleteUpdates.Rows[$i][0]) using the $($WSUSStoreProcedureName) stored procedure." $component 3
                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
            }
        }
    }

    #Clear the progress bar
    Write-Progress -Activity "Deleting Obsolete Updates" -Completed
}

#If the user has decided to decline updates.
$DeclinedUpdates = @{} #Hash table to contain declined updates.
If ($DeclineSuperseded -or $DeclineByTitle -or $DeclineByPlugins){
    
    Invoke-SyncCheck

    #Get a collection of all updates.
    Add-TextToCMLog $LogFile "Retrieving all updates." $component 1
    Try {
	    $Updates = $WSUSServer.GetUpdates()
    } Catch {
	    Add-TextToCMLog $LogFile "Failed to get updates." $component 3	    
        Add-TextToCMLog $LogFile "If this operation timed out, try running the script with only the FirstRun parameter." $component 3
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
	    Set-Location $OriginalLocation
	    Return
    }
    Add-TextToCMLog $LogFile "Retrieved list of updates." $component 1

    Invoke-SyncCheck    

    #Yea, that's right.  We got all the update data just so we could grab the total number.  Pure vanity, I know.
    $countAllUpdates = $Updates.Count
    $Updates = $Updates | Where-Object {$_.IsDeclined -eq $False}

    #Initialize count variables.
    $i = 0                   
    $countDeclined = $countAllUpdates - $Updates.Count
    $countSuperseded = 0        
    $countNewlyDeclined = 0
    $countOther = 0    
    $countDeclinedSuperseded = 0 
    $countDeclinedByTitle = 0
    $countDeclinedByTitleResults = @{}
    $countDeclinedByPlugin = 0
    $countDeclinedByPluginResults = @{}
    ForEach ($SearchString In $DeclineByTitle){$countDeclinedByTitleResults[$SearchString]=0}

    #Now that we have the full update counts let's remove the updates that are already declined.
    
    
    #If no exclusion period was given then use the supersedence configuration of the SUP Component to calculate the exclusion date.
    If ($ExclusionPeriod -eq $null){

        #If expiring immediately then use zero months otherwise use the number of months configured
        If ((((Get-CMSoftwareUpdatePointComponent -SiteCode $SiteCode).Props) | Where-Object {$_.PropertyName -eq 'Sync Supersedence Mode'}).Value -eq 0){
              $ExclusionPeriod = 0 
        } Else {
            $ExclusionPeriod = (((Get-CMSoftwareUpdatePointComponent -SiteCode $SiteCode).Props) | Where-Object {$_.PropertyName -eq 'Sync Supersedence Age'}).Value
        }    
    }
    $ExclusionDate = (Get-Date).AddMonths($ExclusionPeriod * -1)    
  
    #If using the built-in logic for declining superseded updates.
    If($DeclineSuperseded){
        Add-TextToCMLog $LogFile "Declining superseded updates created before $ExclusionDate." $component 1

        #Loop through updates and add those that match the user's criteria to the hash.
        ForEach ($Update in $Updates) {  
                    
            #If we're declining superseded updates, and this update is superseded, and it's not already declined.
            If ($DeclineSuperseded -and $Update.IsSuperseded) {
                #Count the total number of superseded updates.
                $countSuperseded++
                
                #Exclude superseded updates that do not meet the last level or exlusion period criteria.
                If ((($DeclineLastLevelOnly -and !$Update.HasSupersededUpdates) -or !$DeclineLastLevelOnly) -and ($Update.CreationDate -lt $ExclusionDate))  {   
			#region    ######################### Version v2.2 #######################
			#.NOTES Added logic to exclude Feature Update for Windows 10 since the release of Windows 10 v1803 made v1709 superseded but left v1703 as active/ready
			If ($Update.Title -like 'Feature Update to Windows 10*') {
				Add-TextToCMLog $LogFile "Skipping declining superseded Windows 10 Feature update." $component 1
			} Else {
                    		#Add the update to the hash and count the number of superseded updates we decline.
                    		$DeclinedUpdates.Set_Item($Update.Id.UpdateId,"Superseded")
                    		$countDeclinedSuperseded++
			}
			#endregion ######################### Version v2.2 #######################
                }
            }              
            
        } #ForEach Update
    } #DeclineSuperseded

    #If using the built-in logic for declining updates by title.
    If($DeclineByTitle){
        Add-TextToCMLog $LogFile "Declining updates by title." $component 1

        #Loop through updates and add those that match the user's criteria to the hash.
        ForEach ($Update in $Updates) {  
        
            #Loop through each title search string in the array and decline matching updates.
            ForEach ($SearchString In $DeclineByTitle)
            {
                #Find search string matches that aren't already declined by an earlier match.
                If ($Update.Title -like $SearchString)
                {
                    #Add the update to the hash, count it, and set the AlreadyDeclined variable so we don't try to add it again.
                    $DeclinedUpdates.Set_Item($Update.Id.UpdateId,"ByTitle: $SearchString")   
                    $countDeclinedByTitleResults[$SearchString]++
                    $countDeclinedByTitle++                               
                }
            }                                                  
        } #ForEach Update
    } #DeclineByTitle

    #If using external logic then call the plugins.
    If($DeclineByPlugins){

        Invoke-SyncCheck

        #Make sure the plugin folder exists.
	try {
        	$PluginPath = "filesystem::$(Join-Path $PSScriptRoot "Plugins")"
	} catch {
		$PluginPath = "filesystem::$(Join-Path $psISE.CurrentFile.FullPath "Plugins")"
	}
        If (!(Test-Path $PluginPath -PathType Container)){
            Add-TextToCMLog $LogFile "DeclineByPlugins parameter was used but the plugins folder could not be found." $component 2
        } Else {
            Add-TextToCMLog $LogFile "Enumerating and calling plugins." $component 1
                        
            #Loop through each powershell (.ps1) file in the plugin folder.
            ForEach($File in (Get-ChildItem (Join-path $PluginPath "*.ps1") )){
                Add-TextToCMLog $LogFile "Running the $($File.BaseName) plugin." $component 1
                
                Try{
		    Try {
			#Dot source the file in.
                    	. $File
		    } Catch {
		        #Handle PowerShell ISE case where execution policy blocks dot-sourcing
		    	$PluginFileContent = Get-Content -Path $File
			Invoke-Expression -Command $PluginFileContent
			Remove-Variable -Name PluginFileContent
		    }
                    #Verify that the Invoke-SelectUpdatesPlugin command was loaded in from the plugin.
                    If (! (Get-Command Invoke-SelectUpdatesPlugin -errorAction SilentlyContinue))
                    {
                       Add-TextToCMLog $LogFile "The $($File.BaseName) plugin does not contain a function called Invoke-SelectUpdatesPlugin." $component 2
                    } Else {

                        #Call the plugin function and get the returned hash.
                        $pluginHash = Invoke-SelectUpdatesPlugin

                        #Verify that the plugin returned a hash table.
                        If ($pluginHash -IsNot [System.Collections.Hashtable]) {
                            Add-TextToCMLog $LogFile "The $($File.BaseName) plugin did not return a hashtable object and was ignored." $component 2
                        } Else { 

                            #Remove duplicate items from the plugin hash.
                            $duplicates = $DeclinedUpdates.keys | where {$pluginHash.ContainsKey($_)}
                            ForEach ($item in $duplicates) {    
                                $pluginHash.Remove($item)                  
                            }

                            #Join the hash tables.
                            $DeclinedUpdates += $pluginHash                                                    

                            #Count the declined updates by plugin.
                            $countDeclinedByPlugin += $pluginHash.Count
                            $countDeclinedByPluginResults.Set_Item($File.BaseName,$pluginHash.Count)
                        }
                    }

                } Catch {
                    Add-TextToCMLog $LogFile "Failed to load the $($File.BaseName) plugin and call Invoke-SelectUpdatesPlugin function." $component 3
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                } Finally {

                    #Remove the plugin function, ignoring errors in case it wasn't loaded at all.
                    Remove-Item function:\Invoke-SelectUpdatesPlugin -ErrorAction SilentlyContinue -WhatIf:$False                
                }                          
            } #ForEach
        } #Plugin folder found.
    } #DeclineByPlugins parameter passed.
        
    #If updates were selected to be declined then decline them.
    Add-TextToCMLog $LogFile "$($DeclinedUpdates.Count) updates were selected to be declined." $component 1
    If ($DeclinedUpdates.Count -gt 0){
        If ($UpdateListOutputFile){"Update Id,Revision Number,Title,KB Articles,Security Bulletin,Has Superseded Updates,Creation Date,Declined Reason" | Out-File $UpdateListOutputFile -Force -Encoding Default -WhatIf:$False}

        #Loop through updates and decline those that have been selected.
        ForEach ($Update in $Updates) {             

            #Track progress.
            $i++    
            $percentComplete = [math]::Round((($i/$countAllUpdates) * 100))
	    	Write-Progress -Activity "Processing Updates" -Status "Processing update #$i/$countAllUpdates - $($Update.Id.UpdateId)" -PercentComplete $percentComplete -CurrentOperation "$($percentComplete)% complete"
    
            #If the update ID is in the declined update hash then decline it for the reason stated.
            If ($DeclinedUpdates.ContainsKey($Update.Id.UpdateId)){
                Invoke-SyncCheck 

                #Try and decline the update.                			  				        			        
                Try 
                {
                    If (!$WhatIfPreference){$Update.Decline()}
                    If ($UpdateListOutputFile){"$($Update.Id.UpdateId),$($Update.Id.RevisionNumber),""$($Update.Title)"",$($Update.KnowledgeBaseArticles),$($Update.SecurityBulletins),$($Update.HasSupersededUpdates),$($Update.CreationDate),$($DeclinedUpdates.($Update.Id.UpdateId))" | Out-File $UpdateListOutputFile -Append -Encoding Default -WhatIf:$False}
                    Add-TextToCMLog $LogFile "Declined update '$($Update.Title)' (ID: $($Update.Id.UpdateId)). Source: $($DeclinedUpdates.($Update.Id.UpdateId))" $component 1
                    $countNewlyDeclined++
                }
                Catch [System.Exception]
                {
                    Add-TextToCMLog $LogFile "Failed to decline update '$($Update.Title)' (ID: $($Update.Id.UpdateId)). Source: $($DeclinedUpdates.($Update.Id.UpdateId)) Error: $($_.Exception.Message)." $component 3                    
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                }                
            }        
        }

        #Clear the progress bar
        Write-Progress -Activity "Processing Updates"  -Completed

    }
                    
    #Write the summary information.
    If ($UpdateListOutputFile){Add-TextToCMLog $LogFile "List of declined updates: $UpdateListOutputFile" $component 1}    
    If ($WhatIfPreference){ Add-TextToCMLog $LogFile "NOTE: The WhatIf flag was given so the below summary shows what would have happened.  No changes were made." $component 2}
    Add-TextToCMLog $LogFile "Summary:"  $component 1  
    Add-TextToCMLog $LogFile "========" $component 1

    Add-TextToCMLog $LogFile "All Updates = $countAllUpdates" $component 1
    Add-TextToCMLog $LogFile "All Updates Except Declined = $($countAllUpdates - $countDeclined)"   $component 1  
    If ($DeclineSuperseded) {Add-TextToCMLog $LogFile "All Superseded Updates = $countSuperseded" $component 1}
    If ($DeclineSuperseded) {Add-TextToCMLog $LogFile "Superseded Updates Declined = $countDeclinedSuperseded" $component 1}
    If ($DeclineByTitle) {
        ForEach ($result in $countDeclinedByTitleResults.Keys) {
            Add-TextToCMLog $LogFile "Updates Declined by Title for ${result} = $($countDeclinedByTitleResults.Item($result))" $component 1
        }
            
        Add-TextToCMLog $LogFile "Updates Declined by Title (Total) = $countDeclinedByTitle" $component 1
        
    }
    If ($DeclineByPlugins) {
        ForEach ($result in $countDeclinedByPluginResults.Keys) {
            Add-TextToCMLog $LogFile "Updates Declined by Plugin for ${result} = $($countDeclinedByPluginResults.Item($result))" $component 1
        }
            
        Add-TextToCMLog $LogFile "Updates Declined by Plugin (Total Unique) = $countDeclinedByPlugin" $component 1
        
    }
    Add-TextToCMLog $LogFile "Total Newly Declined Updates = $countNewlyDeclined"  $component 1   
    Add-TextToCMLog $LogFile "Total Active Updates = $($countAllUpdates - $countDeclined - $countNewlyDeclined)"  $component 1    
    Add-TextToCMLog $LogFile "========" $component 1
} #If DeclineSuperseded, DeclineByTitle, or DeclineByPlugins

#If selected, run the WSUS cleanup wizard now that we've declined a bunch of stuff.
Try{
    If ($RunCleanupWizard){
        Invoke-SyncCheck

        Add-TextToCMLog $LogFile "Starting the WSUS cleanup wizard."   $component 1   
        
        If ($WhatIfPreference){
            Add-TextToCMLog $LogFile "Finished the WSUS cleanup wizard."   $component 1   
        } Else {
            $cleanupScope = New-Object Microsoft.UpdateServices.Administration.CleanupScope; 
            $cleanupScope.DeclineSupersededUpdates = $true        
            $cleanupScope.DeclineExpiredUpdates         = $true 
            $cleanupScope.CleanupObsoleteUpdates     = $true 
            $cleanupScope.CompressUpdates                  = $true 
            $cleanupScope.CleanupObsoleteComputers = $true 
            $cleanupScope.CleanupUnneededContentFiles = $true 
            $cleanupManager = $WSUSServer.GetCleanupManager(); 
            $cleanupResults = $cleanupManager.PerformCleanup($cleanupScope); 

            Add-TextToCMLog $LogFile "WSUS cleanup wizard has finished successfully:" $component 1
            Add-TextToCMLog $LogFile "    Disk Space Freed: $($cleanupResults.DiskSpaceFreed)." $component 1
            Add-TextToCMLog $LogFile "    Expired Updates Declined: $($cleanupResults.ExpiredUpdatesDeclined)." $component 1
            Add-TextToCMLog $LogFile "    Obsolete Computers Deleted: $($cleanupResults.ObsoleteComputersDeleted)." $component 1
            Add-TextToCMLog $LogFile "    Obsolete Updates Deleted: $($cleanupResults.ObsoleteUpdatesDeleted)." $component 1
            Add-TextToCMLog $LogFile "    Superseded Updates Declined: $($cleanupResults.SupersededUpdatesDeclined)." $component 1
            Add-TextToCMLog $LogFile "    Updates Compressed: $($cleanupResults.UpdatesCompressed)." $component 1
        }
    }
}
catch [System.Exception] 
{
    Add-TextToCMLog $LogFile "Failed to run WSUS cleanup wizard." $component 3
    Add-TextToCMLog $LogFile "You might need to run the WSUS cleanup wizard multiple times for complete success." $component 3
    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    $WSUSServer = $null
}

#If the ReSyncUpdates parameter was used then perform a full sync of updates and wait for it to complete.
#By resyncing before cleaning the SUGs we can be certain to catch any newly declined/expired updates.
If ($ReSyncUpdates){
    Invoke-SyncCheck
   
    #Try to initiate an update sync.
    Try 
    {
        Sync-CMSoftwareUpdate -FullSync $True
        Add-TextToCMLog $LogFile "Initiated a full software update sync and waiting one minute for it to start." $component 1
        If (!$WhatIfPreference) {Start-Sleep -Seconds 60}
        Invoke-SyncCheck
    }
    Catch [System.Exception]
    {
        Add-TextToCMLog $LogFile "Failed to initiate a full update sync.)" $component 3                    
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    }
}

#Remove the updates declined above or expired by Microsoft.
If ($CleanSUGs){
    Add-TextToCMLog $LogFile "Cleaning the Software Update Groups." $component 1

    #Get all the Software Update Groups.
    Try {
        $SoftwareUpdateGroups = Get-CMSoftwareUpdateGroup  
    } Catch {
        Add-TextToCMLog $LogFile "Failed to get software update groups." $component 3                    
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    }

    #Loop through each group, get the updates, and remove those that have been declined or are expired.
    ForEach ($SoftwareUpdateGroup in $SoftwareUpdateGroups){
        
        Add-TextToCMLog $LogFile "Cleaning the $($SoftwareUpdateGroup.LocalizedDisplayName) software update group." $component 1
        $SoftwareUpdateGroupUpdates = Get-CMSoftwareUpdate -UpdateGroup $SoftwareUpdateGroup -Fast

        #Loop through each update and remove those that have been declined or are expired.
        ForEach($Update in $SoftwareUpdateGroupUpdates){            
            If ($Update.IsExpired -or ($DeclinedUpdates.ContainsKey($Update.CI_UniqueID))){
                Add-TextToCMLog $LogFile "Removing $($Update.LocalizedDisplayName) from the $($SoftwareUpdateGroup.LocalizedDisplayName) software update group." $component 1
                
                Try {
                    Remove-CMSoftwareUpdateFromGroup -SoftwareUpdate $Update -SoftwareUpdateGroup $SoftwareUpdateGroup  -Force -WhatIf:$WhatIfPreference
                } Catch {
                    Add-TextToCMLog $LogFile "Failed to get remove '$($Update.LocalizedDisplayName)' from the update group '$($SoftwareUpdateGroup.LocalizedDisplayName)'." $component 3                    
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                }
                
            }
        }

        #Delete SUGs that have no updates in them.
        If($RemoveEmptySUGs){
            If ((Get-CMSoftwareUpdate -UpdateGroup $SoftwareUpdateGroup -Fast).Count -eq 0){
                Add-TextToCMLog $LogFile "Removing the '$($SoftwareUpdateGroup.LocalizedDisplayName)' software update group because it is empty." $component 1

                Try {
                    Remove-CMSoftwareUpdateGroup -InputObject $SoftwareUpdateGroup -Force -WhatIf:$WhatIfPreference
                } Catch {
                    Add-TextToCMLog $LogFile "Failed to remove the '$($SoftwareUpdateGroup.LocalizedDisplayName)' software update group." $component 3                    
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                }
                
            }
        }
    }
}

#Combine the SUGs into a yearly SUG leaving the passed in number of SUGs per ADR.
If ($CombineSUGs){
    Add-TextToCMLog $LogFile "Combining the software update groups into yearly groups leaving $($CombineSUGs) groups for each ADR." $component 1

    #Try to get all the Software Update Groups.
    Try {
        $SoftwareUpdateGroups = Get-CMSoftwareUpdateGroup  
    } Catch {
        Add-TextToCMLog $LogFile "Failed to get software update groups." $component 3                    
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    }
    
    #Try to get all the Automatic Deployment Rules.
    Try {
        $AutomaticDeploymentRules = Get-CMSoftwareUpdateAutoDeploymentRule -Fast  
    } Catch {
        Add-TextToCMLog $LogFile "Failed to get automatic deployment rules." $component 3                    
        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
    }
    
    #Loop through each ADR and find matching SUGs.
    ForEach($AutomaticDeploymentRule in $AutomaticDeploymentRules){

        #Get a list of SUGS sorted by descending creation date where the name matches the ADR and has a date.
        #This is an attempt the match ADRS to SUGs.  While the SUG object has an AssociatedAutoRuleID property it is removed if the ADR is modified in any way.
        $ADRSUGs = $SoftwareUpdateGroups | Where {$_.LocalizedDisplayName -match "$($AutomaticDeploymentRule.Name) \d\d\d\d-\d\d-\d\d"} | Sort-Object DateCreated -Descending

        #If there are more SUGS than the user wants, then add them to the yearly SUG.
        If ($ADRSUGs.Count -gt $CombineSUGs) {

            #Loop through each ADR SUG starting after the number the user wishes to keep.
            ForEach($i in $CombineSUGs..($ADRSUGs.Count-1)){
                $SUG = $ADRSUGs[$i]

                Add-TextToCMLog $LogFile  "Attempting to add '$($SUG.LocalizedDisplayName)' to a yearly software update group." $component 1

                #Get the name of the yearly SUG name based on the ADR name plus the first four digits which are the year.
                $SUG.LocalizedDisplayName -match "$($AutomaticDeploymentRule.Name) \d\d\d\d" | Out-Null
                $YearlySUGName = $Matches[0]

                #Get the yearly SUG if it already exists.
                Try{
                    $YearlySUG = Get-CMSoftwareUpdateGroup -Name $YearlySUGName
                } Catch {
                    Add-TextToCMLog $LogFile "Failed to get the yearly software update group named '$($YearlySUG)'." $component 3                    
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                }
                
                #If the yearly SUG didn't already exist then rename the current SUG and make it the yearly SUG.
                #Otherwise, add the SUG's updates to the yearly SUG and delete the SUG.
                If(!$YearlySUG){
                    Add-TextToCMLog $LogFile  "Could not find a '$($YearlySUGName)' yearly software update group and will rename the '$($SUG.LocalizedDisplayName)' software update group." $component 1

                    Try{
                        Set-CMSoftwareUpdateGroup -InputObject $SUG -NewName $YearlySUGName -WhatIf:$WhatIfPreference
                        $YearlySUG = $SUG
                    } Catch {
                        Add-TextToCMLog $LogFile "Failed to rename the '$($SUG.LocalizedDisplayName)' software update group." $component 3                    
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                    }                
                } Else {
                    
                    #Try to add the SUG's updates to the yearly SUG.
                    Try{
                        Add-TextToCMLog $LogFile  "Adding the updates from the '$($SUG.LocalizedDisplayName)' software update group to the '$($YearlySUGName)' yearly software update group." $component 1
                        Get-CMSoftwareUpdate -UpdateGroup $SUG -Fast | Add-CMSoftwareUpdateToGroup -SoftwareUpdateGroup $YearlySUG -WhatIf:$WhatIfPreference
                    } Catch {
                        Add-TextToCMLog $LogFile "Failed to add the updates from the '$($SUG.LocalizedDisplayName)' software update group to the '$($YearlySUG.LocalizedDisplayName)' yearly software update group." $component 3                    
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3

                        #Skip to the next ADR SUG without removing the current one.
                        Continue 
                    }

                    #Try to delete the SUG.
                    Try{
                        Add-TextToCMLog $LogFile  "Removing the '$($SUG.LocalizedDisplayName)' software update group." $component 1
                        Remove-CMSoftwareUpdateGroup -InputObject $SUG -Force -WhatIf:$WhatIfPreference
                    } Catch {
                        Add-TextToCMLog $LogFile "Failed to delete the '$($SUG.LocalizedDisplayName)' software update group." $component 3                    
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                    }                
                }
            } #ForEach SUG.
        } #Found excess SUGs.    
    } #ForEach ADR
}

#Set the maximum runtime for updates based on the passed in hashtable.
If ($MaxUpdateRuntime){
    #Loop through each value in the hash table.
    ForEach ($Value in $MaxUpdateRuntime.GetEnumerator()) {

        #$Get software updates that match the search string or warn if none are found or configure those that are.
        Add-TextToCMLog $LogFile "Setting the maximum runtime for updates matching '$($Value.Name)' to $($Value.Value) minutes." $component 1  
        $Updates = Get-CMSoftwareUpdate -Name $Value.Name -Fast -IsExpired $False
        If ($Updates.Count -eq 0){
            Add-TextToCMLog $LogFile "No updates matched the search string '$($Value.Name)'." $component 2
        } Else {
            $MaximumRuntimeSeconds = $Value.Value * 60

            #Loop through each update and if the existing runtime doesn't match then try to change it.
            Foreach ($Update in $Updates){
                If ($Update.MaxExecutionTime -ne $MaximumRuntimeSeconds){
                    Try{
                        Set-CMSoftwareUpdate -InputObject $Update -MaximumExecutionMinutes $Value.Value
                        Add-TextToCMLog $LogFile "Set maximum runtime for '$($Update.LocalizedDisplayName)' to $($Value.Value) minutes." $component 1               
                    } Catch {
                        Add-TextToCMLog $LogFile "Failed to set maximum runtime for '$($Update.LocalizedDisplayName)'." $component 3                    
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                    }
                }
            }
        }
    }
}

#This is essentially a re-write of the content clean routine released by Microsoft here: 
#  https://blogs.technet.microsoft.com/enterprisemobility/2012/04/12/software-update-content-cleanup-in-system-center-2012-configuration-manager/
If ($CleanSources){    
    If ($WhatIfPreference){ Add-TextToCMLog $LogFile "NOTE: The WhatIf flag was given so no changes will be made from the deployment package source folders." $component 2}

    #Loop through each deployment package
    ForEach ($UpdateDeploymentPackage in Get-CMSoftwareUpdateDeploymentPackage){
            
        Add-TextToCMLog $LogFile "Cleaning update source files for $($UpdateDeploymentPackage.Name) with source path $($UpdateDeploymentPackage.PkgSourcePath)." $component 1                
        
        #Remove orphaned package-to-content relations that are not associated with CIs
        #TODO: I haven't seen this in the wild yet to test this method out so right now it just spits out to the log.
        $ContentQuery = "select pc.* from SMS_PackageToContent pc left join SMS_CIToContent cc on cc.ContentID=pc.ContentID where pc.PackageID=""$($UpdateDeploymentPackage.PackageID)"" and cc.ContentID is null"
        Foreach ($packageToContent in (Get-WmiObject -Namespace "root\SMS\site_$($SiteCode)" -Query $ContentQuery)){
            Add-TextToCMLog $LogFile "The deployment package $($UpdateDeploymentPackage.Name) has orphaned content (ID: $($packageToContent.ContentID))." $component 2
        }

        $PackageSourcePath="filesystem::$($UpdateDeploymentPackage.PkgSourcePath)"
        If (! (Test-Path $PackageSourcePath -PathType Container)){
            Add-TextToCMLog $LogFile "The deployment package $($UpdateDeploymentPackage.Name)'s source path ($($UpdateDeploymentPackage.PkgSourcePath)) does not exist." $component 2
        } Else {
            
            Try 
            {
                #Get the list of content subfolders for the deployment package.
                $ContentSubFolders = (Get-WmiObject -Namespace "ROOT\SMS\site_$($SiteCode)" -Query "Select * from SMS_PackageToContent where PackageID='$($UpdateDeploymentPackage.PackageID)'").ContentSubFolder
            }
            Catch [System.Exception]
            {
                Add-TextToCMLog $LogFile "Failed to get the content folders from the SMS_PackageToContent WMI class for Package ID $($UpdateDeploymentPackage.PackageID) ." $component 3                    
                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
            }
            
            #Loop though the folders in the deployment package source folder and delete any that are no longer referenced.                
            ForEach($Folder in (Get-ChildItem $PackageSourcePath -Directory)){
                    
                If (! $ContentSubFolders.Contains($Folder.Name) ){
                    Try{
                        $FolderPath = Join-Path $PackageSourcePath $Folder.Name
                        Remove-Item $FolderPath -Recurse -Force -WhatIf:$WhatIfPreference
                        Add-TextToCMLog $LogFile "Removing folder '$($FolderPath)' from the deployment package $($UpdateDeploymentPackage.Name)." $component 1
                    }

                    Catch [System.Exception]
                    {
                        Add-TextToCMLog $LogFile "Failed to remove folder $($FolderPath) from the deployment package $($UpdateDeploymentPackage.Name)." $component 3                    
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                    }
                }
            }                
            
        }
    }
}

If ($UpdateADRDeploymentPackages){

    #Set the deployment package period according to the parameter.
    If($UpdateADRDeploymentPackages -eq "Yearly"){
        $DeploymentPackagePeriod = (Get-Date).Year
    } ElseIf ($UpdateADRDeploymentPackages -eq "Monthly") {
        $DeploymentPackagePeriod = Get-Date -Format 'yyMM'
    }

    #Make sure a valid parameter was sent.
    If (!$DeploymentPackagePeriod){
        Add-TextToCMLog $LogFile "An invalid UpdateADRDeploymentPackages parameter was sent.  The deployment packages were unchanged." $component 3
    } Else {
        Add-TextToCMLog $LogFile "Verifying that all automatic deployment rules are using a deployment package for the $($DeploymentPackagePeriod) period." $component 1

        #Try to get all the Automatic Deployment Rules.
        Try {
            $CMPSSuppressFastNotUsedCheck = $True
            $AutomaticDeploymentRules = Get-CMSoftwareUpdateAutoDeploymentRule  
            $CMPSSuppressFastNotUsedCheck = $False
        } Catch {
            Add-TextToCMLog $LogFile "Failed to get automatic deployment rules." $component 3                    
            Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
            Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
        }

        #Loop through each ADR.
        ForEach ($AutomaticDeploymentRule in $AutomaticDeploymentRules){
            
            #Ignore any ADRs that are disabled.
            If(!$AutomaticDeploymentRule.AutoDeploymentEnabled){
                Add-TextToCMLog $LogFile "Ignoring the '$($AutomaticDeploymentRule.Name)' automatic deployment rule because it is disabled. " $component 1
                Continue #Go to the next ADR.
            }

            #Try to get the deployment package name.
            Try {
                $DeploymentPackageID = ([xml]$AutomaticDeploymentRule.ContentTemplate).ContentActionXML.PackageID
            } Catch {
                Add-TextToCMLog $LogFile "Failed to get the deployment package ID for '$($AutomaticDeploymentRule.Name)'." $component 3
                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                Continue #Go to the next ADR.
            }

            #Try to get the deployment package.
            Try {
                $DeploymentPackage = Get-CMSoftwareUpdateDeploymentPackage -Id $DeploymentPackageID                
            } Catch {
                Add-TextToCMLog $LogFile "Failed to get the deployment package name for '$($AutomaticDeploymentRule.Name)'." $component 3
                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                Continue #Go to the next ADR.
            }

            
            $CorrectDeploymentPackageName = $DeploymentPackage.Name -replace '\d\d\d\d$', $DeploymentPackagePeriod            
            #If the deployment package name doesn't end in four digits then warning the user.
            If ($DeploymentPackage.Name -notmatch ".+?\d\d\d\d$"){
                Add-TextToCMLog $LogFile "The deployment package '$($DeploymentPackage.Name)' for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule does not end in four digits and cannot be update automatically. If you want it updated automatically rename it to end in four digits representing either the year or month in YYMM form. " $component 2
            #If the deployment package is already correct do nothing.  
            } ElseIf($DeploymentPackage.Name -eq $CorrectDeploymentPackageName) {
                #Do nothing.
            #Otherwise update the ADR to use the correct deployment package.
            } Else {

                #Try to see if the correct deployment package exists.
                Try {
                    $CorrectDeploymentPackage = Get-CMSoftwareUpdateDeploymentPackage -Name $CorrectDeploymentPackageName
                } Catch {
                    Add-TextToCMLog $LogFile "Failed to search for the the deployment package '$($CorrectDeploymentPackageName)'." $component 3
                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                }

                #If the correct deployment package doesn't exist then create it.
                If(!$CorrectDeploymentPackage){
                    Add-TextToCMLog $LogFile "The correct deployment package '$($CorrectDeploymentPackageName)' for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule does not exist and will be created." $component 1
                   
                    #Make sure that the existing deployment package's source path ends in four digits just like its name.
                    If ($DeploymentPackage.PkgSourcePath -notmatch ".+?\d\d\d\d$"){
                        Add-TextToCMLog $LogFile "The source path for deployment package '$($DeploymentPackage.Name)' for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule does not end in four digits and cannot be update automatically. If you want it updated automatically rename it to end in four digits representing either the year or month in YYMM form. " $component 2
                    } Else {

                        #Calculate the new deployment package's source path and make sure it does not exist.
                        $NewDeploymentPackageSourcePath = $DeploymentPackage.PkgSourcePath -replace '\d\d\d\d$', $DeploymentPackagePeriod
                        If (Test-Path "filesystem::$($NewDeploymentPackageSourcePath)") {
                           Add-TextToCMLog $LogFile "Could not create the new '$($CorrectDeploymentPackageName)' deployment package for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule.  The source path '$($NewDeploymentPackageSourcePath)' already exists. " $component 3
                        } Else {
                            
                            #Try to create the new source path.
                            Try {
                                New-Item "filesystem::$($NewDeploymentPackageSourcePath)" -ItemType "directory" -Force -WhatIf:$WhatIfPreference | Out-Null
                            } Catch {
                                Add-TextToCMLog $LogFile "Failed to create a new deployment package source folder '$($NewDeploymentPackageSourcePath)'for the the deployment package '$($CorrectDeploymentPackageName)'." $component 3
                                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                                Continue #Go to the next ADR.
                            }

                            #Try to create the new deployment package.
                            Try {
                                $CorrectDeploymentPackage = New-CMSoftwareUpdateDeploymentPackage -Name $CorrectDeploymentPackageName -Path $NewDeploymentPackageSourcePath -WhatIf:$WhatIfPreference
                                Add-TextToCMLog $LogFile "Created the new '$($CorrectDeploymentPackage.Name)' deployment package with ID '$($CorrectDeploymentPackage.PackageID)'." $component 1
                            } Catch {
                                Add-TextToCMLog $LogFile "Failed to create a new deployment package '$($CorrectDeploymentPackage.Name)' for the the '$($AutomaticDeploymentRule.Name)' automatic deployment rule." $component 3
                                Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                                Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                                Continue #Go to the next ADR.
                            }
                            
                            #Get and loop through each distribution of the current package and distribute the new one to it.
                            Add-TextToCMLog $LogFile "Distributing the new '$($CorrectDeploymentPackage.Name)' deployment package." $component 1
                            $DeploymentPackageDistribution = Get-WmiObject -Namespace "ROOT\SMS\site_$($SiteCode)" -Query "SELECT Name, ContentServerType FROM SMS_PackageContentServerInfo WHERE ObjectID = '$($DeploymentPackage.PackageId)' And ContentServerID Not In (Select NALPath From SMS_MigrationDP)"
                            ForEach ($Distribution in $DeploymentPackageDistribution){
                                
                                Try {
                                    If ($WhatIfPreference){
                                        #Do nothing since the new package wasn't really created which will cause the following lines to fail.
                                    } ElseIf($Distribution.ContentServerType -eq 1){
                                        Start-CMContentDistribution -DeploymentPackageId $CorrectDeploymentPackage.PackageID -DistributionPointName ($Distribution.Name  -replace "\\\\","")
                                    } ElseIf($Distribution.ContentServerType -eq 2){
                                        Start-CMContentDistribution -DeploymentPackageId $CorrectDeploymentPackage.PackageID -DistributionPointGroupName $Distribution.Name
                                    } Else {
                                        Add-TextToCMLog $LogFile "Failed to deploy the new deployment package '$($CorrectDeploymentPackage.Name)' for the the '$($AutomaticDeploymentRule.Name)' automatic deployment rule to '$($Distribution.Name)'.  The server type '$($Distribution.ContentServerType)' is unknown." $component 3
                                    }
                                } Catch {
                                    Add-TextToCMLog $LogFile "Failed to deploy the new deployment package '$($CorrectDeploymentPackage.Name)' for the the '$($AutomaticDeploymentRule.Name)' automatic deployment rule to '$($Distribution.Name)'." $component 3
                                    Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                                    Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                                }
                            }
                        } #Source path exists.
                    } #Source path conforms to naming standard.
                } #Correct deployment package doesn't exist.

                #If the correct deployment package doesn't exist then warn the user and do nothing.
                If(!$CorrectDeploymentPackage){
                    Add-TextToCMLog $LogFile "The correct deployment package '$($CorrectDeploymentPackageName)' for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule does not exist and could not be created." $component 3
                } Else {
                    #Try to change the ADR's deployment package to the correct one.
                    Try {
                        Add-TextToCMLog $LogFile "Changing the deployment package for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule from '$($DeploymentPackage.Name)' to '$($CorrectDeploymentPackageName)'." $component 1
                        If (!$WhatIfPreference){

                            #Do some XML voodoo to update the package ID.  Boy wouldn't it be great to be able to properly get and set this with the cmdlets?
                            [xml]$ContentTemplateXML = $AutomaticDeploymentRule.ContentTemplate
                            $ContentTemplateXML.ContentActionXML.PackageId = $CorrectDeploymentPackage.PackageId
                            $AutomaticDeploymentRule.ContentTemplate = $ContentTemplateXML.OuterXml
                            $AutomaticDeploymentRule.Put()
                        }
                    } Catch {
                        Add-TextToCMLog $LogFile "Failed to change the the deployment package for the '$($AutomaticDeploymentRule.Name)' automatic deployment rule to '$($CorrectDeploymentPackageName)'." $component 3
                        Add-TextToCMLog $LogFile "Error: $($_.Exception.Message)" $component 3
                        Add-TextToCMLog $LogFile "$($_.InvocationInfo.PositionMessage)" $component 3
                    }
                }
            } #Deployment package needs to be changed.               
        } #ForeEach ADR.
    } #Invalid parameter.
}

Add-TextToCMLog $LogFile "$component finished." $component 1
Set-Location $OriginalLocation

#Mark the last time the script ran.
Get-Date | Out-File $lastRanPath -Force -WhatIf:$False
